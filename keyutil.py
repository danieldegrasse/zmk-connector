import keycodes
import subprocess
import json
import argparse
import re

"""
Help string we add to generated JSON for user's benefit
"""
HELPSTR = """# Generated by keymap_util.py for ZMK keyboards. This data describes keys
# as an array of arrays. Each array within the root array represents a key
# layer. For example, a 4 key 2 layer keyboard might have the following
# definition:
# [
#   [
#     "KEY_A",
#     "KEY_B",
#     "KEY_C",
#     "MO_LAYER_1",
#   ],
#   [
#     "KEY_C_NEXT",
#     "KEY_C_PLAY_PAUSE",
#     "KEY_C_MUTE",
#     "KEY_C_PREV",
#   ]
# ]
#
# The following behavior types are known to this program:
# - Key Press. See https://zmk.dev/docs/codes for list.
#   All key names should be prepended with \"KEY_\"
# - Momentary Layers. Names are given based on the layer index,
#   IE MO_LAYER_2 to select layer 2.
# - Bootloader entry. Simply add \"BOOTLOADER\" to your keymap.
#
# Keys can be read with \"keymap_util.py read_keys\", and
# programmed with \"keymap_util.py write_keys [json_file]\"

"""

"""
Converts raw key dictionary from keyboard to a human readable key description
@param raw_key: raw key dictionary
@retval: Human readable key string
"""
def raw_to_key(raw_key):
    if raw_key["behavior_id"] == 5:
        # Keyboard behavior
        hid_usage= int(raw_key["param1"])
        return f"KEY_{keycodes.keycode_to_desc(hid_usage)}"
    elif raw_key["behavior_id"] == 16:
        # Momentary Layer selector
        return f"MO_SEL_LAYER_{raw_key['param1']}"
    elif raw_key["behavior_id"] == 20:
        # Bootloader selector
        return "BOOTLOADER"
    elif raw_key["behavior_id"] == 17:
        return "NONE"
    else:
        return f"UNKNOWN({raw_key['behavior_id']}, {raw_key['param1']}, {raw_key['param2']})"

"""
Converts human readable key description into raw key object
@param keystr: Human readable key string
"""
def key_to_raw(keystr):
    if keystr.startswith("KEY_"):
        behavior_id = 5
        param1 = keycodes.desc_to_keycode(keystr[4:])
        param2 = 0
    elif keystr.startswith("MO_"):
        behavior_id = 16
        param1 = int(re.match(r"MO_SEL_LAYER_(\d+)", keystr).group(1))
        param2 = 0
    elif keystr == "BOOTLOADER":
        behavior_id = 20
        param1 = 0
        param2 = 0
    elif keystr == "NONE":
        behavior_id = 17
        param1 = 0
        param2 = 0
    elif "UNKNOWN" in keystr:
        # Unknown key type. Parse behavior ID and key params
        match = re.match(r'UNKNOWN\((\d+), (\d+), (\d+)\)', keystr)
        if match is None:
            sys.exit(f"Error, key string {keystr} is formatted incorrectly")
        behavior_id = int(match.group(1))
        param1 = int(match.group(2))
        param2 = int(match.group(3))
    else:
        sys.exit(f"Error, invalid key string {keystr}")

    return {"behavior_id": behavior_id, "param1": param1, "param2": param2}

"""
Prompts user with list of connected keyboards,
and returns serial of selected keyboard
"""
def select_keyboard():
    # Read all connected ZMK device serials
    res = subprocess.run(["./zmk-connector", "list_devices"], capture_output=True)
    if res.returncode != 0:
        print(res.stdout.decode('utf8'))
        print(f"Error, could not list ZMK compatible devices ({res.returncode})")
        exit(res.returncode)

    # Parse ZMK device serial JSON
    devices = json.loads(res.stdout)
    print("Please select a device")
    for i in range(len(devices)):
        device = devices[i]
        print(f"[{i}] {device['product']} ({device['serial']})")
    sel = input("selection: ")
    return devices[int(sel)]["serial"]

"""
Reads all keys from keyboard.
Returns array of keyboard layers. Each layer is an array of keys
@param device_serial: Serial number to read keys from
"""
def read_keys(device_serial):
    # read keys from ZMK device
    print("Reading keys. The helper program will likely request your password...")
    res = subprocess.run(["sudo", "./zmk-connector", "read_features", device_serial],
                        capture_output=True)
    if res.returncode != 0:
        print(res.stdout.decode('utf8'))
        print(f"Error, could not read features from keyboard ({res.returncode})")
        exit(res.returncode)

    features = json.loads(res.stdout)
    raw_keydata = []
    for layer in range(features["layer_count"]):
        # Read all keys in layer
        layerdata = []
        for key in range(features["keycount"]):
            res = subprocess.run(["sudo", "./zmk-connector", "read_key",
                                 device_serial, str(layer), str(key)],
                                 capture_output=True)
            if res.returncode != 0:
                print(res.stdout.decode('utf8'))
                print(f"Error, could not read key {layer},{key} from keyboard "
                      f"({res.returncode})")
                exit(res.returncode)
            keydata = json.loads(res.stdout)
            layerdata.append(keydata)
        raw_keydata.append(layerdata)

    parsed_keydata = []
    for layer in raw_keydata:
        parsed_layer = []
        for key in layer:
            parsed_layer.append(raw_to_key(key))
        parsed_keydata.append(parsed_layer)
    return parsed_keydata

"""
Writes keys to keyboard
Keys are programmed based on an array of arrays. Each array within the root
array represents the keys in a given layer
@param device_serial: Serial number to write keys to
@param key_data: key data array to write.
"""
def write_keys(device_serial, key_data):
    # Parse key data to ZMK format
    raw_keydata = []
    for layer in key_data:
        raw_layer = []
        for key in layer:
            raw_layer.append(key_to_raw(key))
        raw_keydata.append(raw_layer)
    # Write keydata to keyboard
    print("Writing keys. The helper program will likely request your password...")
    for layer_idx in range(len(raw_keydata)):
        for key_idx in range(len(layer)):
            key = raw_keydata[layer_idx][key_idx]
            res = subprocess.run(["sudo", "./zmk-connector", "set_key",
                                 device_serial,
                                 json.dumps(key),
                                 str(layer_idx), str(key_idx)],
                                 capture_output=True)
            if res.returncode != 0:
                print(res.stdout.decode('utf8'))
                print(f"Error, could not set key to keyboard ({res.returncode})")
                exit(res.returncode)

"""
Parses program arguments
"""
def parse_args():
    parser = argparse.ArgumentParser(prog="zmk-keyutil.py",
                                     description="manage ZMK keyboard keymap")
    parser.add_argument("-s", "--serial", help="Serial number of keyboard to manage")
    commands = parser.add_subparsers(help="Keyboard management commands",
                                     dest="cmd")
    read_keys = commands.add_parser("read_keys",
                                    help="Read keys from keyboard into JSON array")
    read_keys.add_argument("--file",
                           help="File to write JSON array into",
                           default="keys.json")
    write_keys = commands.add_parser("write_keys",
                                    help="Write keys to keyboard from JSON array")
    write_keys.add_argument("file", help="File to read JSON array from")
    save_keys = commands.add_parser("save_keys",
                                    help="Make current key settings persistent")
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()
    if args.serial is None:
        # Prompt user for serial
        args.serial = select_keyboard()
    if args.cmd == "read_keys":
        keydata = read_keys(args.serial)
        f = open(args.file, "w")
        f.write(HELPSTR)
        json.dump(keydata, f, sort_keys=True, indent=4)
        f.close()
        print(f"Key data written to {args.file}")
    elif args.cmd == "write_keys":
        f = open(args.file, "r")
        # Strip the comment block from the JSON data
        json_str = ""
        line = f.readline()
        while line != "":
            if not line.startswith("#"):
                json_str += line
            line = f.readline()
        f.close()
        key_data = json.loads(json_str)
        write_keys(args.serial, key_data)
        print(f"Key data from {args.file} written to keyboard")
    elif args.cmd == "save_keys":
        print("Saving key settings. The helper program will likely request your password...")
        res = subprocess.run(["sudo", "./zmk-connector", "commit_keys",
                             args.serial], capture_output=True)
        if res.returncode != 0:
            print(res.stdout.decode('utf8'))
            print(f"Error, could not save keys to keyboard ({res.returncode})")
            exit(res.returncode)

    else:
        print("Error, unknown command")
